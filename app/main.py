from typing import Annotated
from fastapi import FastAPI, HTTPException, Depends, Query
from sqlmodel import Session, create_engine, select, SQLModel

from .utils import Calculator
from .model import Receipt, StoredData

app = FastAPI()
calculator = Calculator()

# Database kept in-memory. Stores a receipt id and its receipt
SQL_FILENAME = "database.db"
SQL_URL = f"sqlite:///{SQL_FILENAME}"

# allows use of the same database for different threads, 
# one request could use multiple threads
connect_args = {'check_same_thread': False} 
engine = create_engine(SQL_URL, connect_args=connect_args, echo=True)

def create_db_and_tables():
    """
    Creates tables for all table models.
    """
    SQLModel.metadata.create_all(engine)

def get_session():
    """
    Stores objects in memory, traking changes in data, and communicates to the 
    database using engine. Each request provides a new session. One session
    for each individual request
    """
    with Session(engine) as session:
        yield session

SessionDep = Annotated[Session, Depends(get_session)]


# endpoints and api calls
@app.on_event('startup')
def on_startup():
    """
    Upon startup, a new database and tables are created.
    """
    create_db_and_tables()


@app.get('/receipts/{id}/points')
async def process_receipts(id: str, session: SessionDep) -> None:
    """
    Takes in a JSON receipt (see example in the example directory) and returns a 
    JSON object with an ID generated by your code.

    The ID returned is the ID that should be passed into /receipts/{id}/points to 
    get the number of points the receipt was awarded.

    How many points should be earned are defined by the rules below.

    Reminder: Data does not need to survive an application restart. This is to allow 
    you to use in-memory solutions to track any data generated by this endpoint.

    { "id": "7fb1377b-b223-49d9-a31a-5a02701dd310" }
    """
    data = session.get(StoredData, id)

    # raises 404 error when a receipt id cannot be found
    if not data:
        raise HTTPException(status_code=404, detail=f'No receipt for id, {id}.')

    return {'points': data.id}

@app.post('/receipts/process')
async def get_points(receipt: Receipt, session: SessionDep) -> None:
    """
    A simple Getter endpoint that looks up the receipt by the ID and returns an object 
    specifying the points awarded.

    NOTE: automatically raises a 422 error if any Receipt field is missing or wrong type

    { "points": 32 }
    """    
    # error handeling in case no items in reciept
    if len(receipt.items) == 0:
        raise HTTPException(status_code=400, detail=f'Items list empty. Please ensure items are populated.')

    # create ID for receipt
    receipt_id = calculator.create_id()
    
    # calculate points and add to database
    points, message = calculator.calculate(receipt)
    data = StoredData(
        id=receipt_id,
        points=points
    )

    session.add(data)
    session.commit()
    session.refresh(data)

    # prints point calculation breakdown to terminal
    print(message)

    return {'id': receipt_id}

@app.delete('/receipts/{id}')
def delete_points(id: str, session: SessionDep):
    data = session.get(StoredData, id)
    if not data:
        raise HTTPException(status_code=404, detail=f'No receipt for id, {id}.')
    
    session.delete(data)
    session.commit()
    return {'success': f'Data deleted for id {id}'}

@app.get('/receipts')
def read_receipts(session: SessionDep, offset: int=0, limit: Annotated[int, Query(le=100)] = 100) -> list[StoredData]:
    data = session.exec(select(StoredData).offset(offset).limit(limit)).all()
    return data